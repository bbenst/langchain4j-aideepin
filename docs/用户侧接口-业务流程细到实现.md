# 用户侧接口-业务流程细到实现

本文档面向用户侧（`adi-chat` + `adi-common`），细化到关键方法、状态流转与核心实体（不展开到具体代码行）。

## 认证与账号

### 1. 注册
1. 入口：`POST /auth/register` → `UserService.register`。
2. 校验注册验证码：从 Redis 读取 `AUTH_REGISTER_CAPTCHA_ID` 对应的验证码，失败则抛错。
3. 邮箱去重：检查未删除用户是否已存在，存在且已激活则拒绝，存在但未激活则重发激活邮件。
4. 发送激活邮件：`sendActiveEmail` 写入激活码到 Redis（`AUTH_ACTIVE_CODE`），发邮件携带激活链接。
5. 创建用户：BCrypt 加密密码，状态置为 `WAIT_CONFIRM`，插入 `User`。
6. 初始化默认会话：`ConversationService.createDefault` 写入默认 `Conversation`。

关键实体：`User`，`Conversation`。关键缓存：注册验证码、激活码。

### 2. 激活
1. 入口：`GET /auth/active` → `UserService.active`。
2. 校验激活码：从 Redis 读取 `AUTH_ACTIVE_CODE`，失败则抛错。
3. 更新用户状态：`user_status` → `NORMAL`，设置 `active_time`。
4. 写入登录令牌：生成 Token，写入 Redis `USER_TOKEN`。

关键实体：`User`。关键缓存：激活码、用户 Token。

### 3. 登录
1. 入口：`POST /auth/login` → `UserService.login`。
2. 登录失败次数判断：读取 Redis `LOGIN_FAIL_COUNT`，超过阈值则强制验证码校验。
3. 校验密码：BCrypt 比对失败则累计失败次数并抛错。
4. 校验用户状态：未激活则拒绝。
5. 写入登录令牌：调用 `setLoginToken`，把用户信息写入 Redis。
6. 返回响应：控制器返回 Token，并写入 `Authorization` 响应头与 Cookie。

关键实体：`User`。关键缓存：登录失败次数、登录验证码、用户 Token。

### 4. 忘记密码与重置
1. 入口：`POST /auth/password/forgot` → `UserService.forgotPassword`。
2. 生成重置码：写入 Redis `FIND_MY_PASSWORD`，设置有效期。
3. 发送重置邮件：链接指向 `/auth/password/reset`。
4. 入口：`GET /auth/password/reset` → `UserService.resetPassword`。
5. 校验重置码并重置密码：把密码重置为默认值并清理 Redis。

关键实体：`User`。关键缓存：重置码。

### 5. 修改密码与登出
1. 修改密码入口：`POST /user/password/modify` → `UserService.modifyPassword`。
2. 校验旧密码，更新新密码。
3. 登出入口：`POST /user/logout` → `UserService.logout`。
4. 删除 Redis `USER_TOKEN`。

关键实体：`User`。关键缓存：用户 Token。

## 会话与消息（聊天）

### 1. 会话创建与编辑
1. 创建入口：`POST /conversation/add` → `ConversationService.add`。
2. 校验标题唯一性，过滤可用 MCP 与知识库。
3. 写入 `Conversation` 并返回 DTO。
4. 预设创建入口：`POST /conversation/addByPreset` → `ConversationService.addByPresetConv`，写入 `ConversationPresetRel`。
5. 编辑入口：`POST /conversation/edit/{uuid}` → `ConversationService.edit`，更新会话配置、MCP、知识库、语音配置。

关键实体：`Conversation`，`ConversationPreset`，`ConversationPresetRel`。

### 2. 会话详情
1. 入口：`GET /conversation/{uuid}` → `ConversationService.detail`。
2. 通过 `maxMsgUuid` 定位锚点，查询问题消息列表（`parent_message_id = 0`）。
3. 组装附件 URL 与音频 URL。
4. 查询回答消息并按父子关系组装。

关键实体：`Conversation`，`ConversationMessage`，`AdiFile`。

### 3. 发送消息（SSE）
1. 入口：`POST /conversation/message/process` → `ConversationMessageService.sseAsk`。
2. 校验：对话是否删除、会话数量限制、用户配额、请求限流等。
3. 语音输入处理：若 `audioUuid` 存在，读取音频并调用 ASR 转文本。
4. 构建检索：
- 记忆检索：基于对话 ID 召回短期记忆。
- 知识库检索：过滤可用知识库后做向量或图谱召回。
5. 组装 Prompt：记忆 + 知识库内容 + 语音回答指令。
6. 调用 LLM：通过 `SSEEmitterHelper.call` 流式推送结果。
7. 处理音频输出：若返回音频路径则保存为 `AdiFile` 并生成 URL。
8. 落库：
- 保存问题消息（`ConversationMessage`，角色 USER）。
- 保存回答消息（角色 ASSISTANT），记录 tokens 与引用标记。
- 创建引用记录（向量或图谱）。
9. 记忆与成本：
- 更新短期记忆（MapDB）。
- 写入长期记忆。
- 更新对话与用户日成本。

关键实体：`Conversation`，`ConversationMessage`，`ConversationMessageRefEmbedding`，`ConversationMessageRefGraph`，`AdiFile`，`UserDayCost`。

## 知识库（RAG）

### 1. 知识库创建与更新
1. 入口：`POST /knowledge-base/saveOrUpdate` → `KnowledgeBaseService.saveOrUpdate`。
2. 设置抽取模型：未显式指定则使用第一个可用模型。
3. 新建或更新 `KnowledgeBase`。

关键实体：`KnowledgeBase`。

### 2. 文档上传与知识点生成
1. 入口：`POST /knowledge-base/upload/{uuid}` 或 `/uploadDocs/{uuid}`。
2. 保存文件：`FileService.saveFile`，生成 `AdiFile`。
3. 解析文档：`FileOperatorContext.loadDocument`。
4. 创建知识点：写入 `KnowledgeBaseItem`，保存正文与摘要。
5. 自动索引：若开启则调用 `indexItems`。

关键实体：`AdiFile`，`KnowledgeBaseItem`。

### 3. 索引流程
1. 索引入口：`POST /knowledge-base/indexing/{uuid}` → `KnowledgeBaseService.indexing`。
2. 校验权限后逐条触发 `KnowledgeBaseItemService.asyncIndex`。
3. 防重复索引：使用 Redis `USER_INDEXING` 标识用户索引中。
4. 定时统计：`asyncUpdateStatistic` 更新知识库嵌入数量。

关键实体：`KnowledgeBase`，`KnowledgeBaseItem`。关键缓存：索引标识、统计更新信号。

### 4. 知识库问答（SSE）
1. 创建问答记录：`POST /knowledge-base/qa/add/{kbUuid}` → `KnowledgeBaseQaService.add`。
2. SSE 入口：`POST /knowledge-base/qa/process/{qaRecordUuid}` → `KnowledgeBaseService.sseAsk`。
3. 请求限额：使用 Redis `AQ_ASK_TIMES` 做每日限流。
4. 召回与推理：
- 计算可用最大召回数。
- 严格模式下超长问题直接拒绝。
- 生成检索器并执行 `CompositeRag.ragChat`。
5. 更新问答记录与引用：写入答案、token、引用（向量或图谱）。
6. 计费与成本：更新用户日成本。

关键实体：`KnowledgeBaseQa`，`KnowledgeBaseQaRefEmbedding`，`KnowledgeBaseQaRefGraph`，`UserDayCost`。

## 绘图（文生图/图生图/修图）

### 1. 创建绘图任务
1. 入口：`POST /draw/generation` → `DrawService.createByPrompt`。
2. 额度与频控：校验用户绘图配额、限流与进行中标记。
3. 写入 `Draw`：状态 `STATUS_DOING`。
4. 异步生成：`createFromRemote` 调用图片模型服务生成图片。

关键实体：`Draw`，`AdiFile`。关键缓存：用户绘图中标记。

### 2. 远程生成与落库
1. 拉取图片：根据交互类型调用不同模型方法。
2. 保存图片：`FileService.saveImageFromUrl` 生成 `AdiFile`。
3. 更新任务状态：成功写入 `STATUS_SUCCESS` 与图片 UUID，失败写入 `STATUS_FAIL`。
4. 累计成本：写入或更新 `UserDayCost`。

关键实体：`Draw`，`AdiFile`，`UserDayCost`。

### 3. 重新生成
1. 入口：`POST /draw/regenerate/{uuid}`。
2. 仅允许失败任务，重新触发远程生成。

关键实体：`Draw`。

## AI 搜索（SSE）

### 1. 搜索请求
1. 入口：`POST /ai-search/process` → `SearchService.search`。
2. 调用搜索引擎，返回候选链接并推送到 SSE。
3. 分支：简要搜索或详情搜索。

### 2. 简要搜索
1. 拼接摘要内容为提示词。
2. 直接调用 LLM，落库 `AiSearchRecord`。
3. 写入 token 成本。

### 3. 详情搜索
1. 保存 `AiSearchRecord` 基础信息。
2. 并发抓取网页正文或摘要，写入向量库（RAG）。
3. 创建检索器并执行 `CompositeRag.ragChat`。
4. 更新 `AiSearchRecord`，写入答案与 token。

关键实体：`AiSearchRecord`，向量检索相关对象。

## 工作流

### 1. 运行（SSE）
1. 入口：`POST /workflow/run/{wfUuid}` → `WorkflowStarter.streaming`。
2. 校验流程是否启用并异步启动。
3. `WorkflowEngine.run` 创建运行实例 `WorkflowRuntime` 并写入输入。
4. 构建状态图，执行节点并流式返回。
5. 若遇到“人机交互”节点，进入等待状态并保存运行状态。

关键实体：`WorkflowRuntime`，`WorkflowRuntimeNode`。

### 2. 恢复执行
1. 入口：`POST /workflow/runtime/resume/{runtimeUuid}` → `WorkflowStarter.resumeFlow`。
2. 从内存获取运行图并继续执行。

关键实体：`WorkflowRuntime`。

## 文件

### 1. 上传与访问
1. 上传入口：`POST /file/upload` 或 `/image/upload`。
2. 去重：按文件 SHA256 判断是否已存在。
3. 写入 `AdiFile` 并返回 URL。
4. 访问入口：`GET /file/{uuidWithExt}`，读取文件或图片并输出。

关键实体：`AdiFile`。

## 模型与系统配置

### 1. 模型列表
1. 入口：`GET /model/llms` 与 `/imageModels`。
2. 读取已启用的模型信息并返回。

### 2. 系统配置
1. 入口：`GET /sys/config/public/info`。
2. 读取 ASR/TTS 配置并解析可用音色列表。

关键实体：`AiModel`，系统配置缓存。

## MCP（工具市场）

### 1. MCP 查询
1. 入口：`GET /mcp/public/search` 与 `/public/list`。
2. 搜索与批量查询 MCP 记录。

### 2. 用户 MCP
1. 入口：`GET /user/mcp/list`。
2. 读取当前用户启用的 MCP 列表。
3. 入口：`POST /user/mcp/saveOrUpdate` 保存用户 MCP 配置。

关键实体：`Mcp`，`UserMcp`。
